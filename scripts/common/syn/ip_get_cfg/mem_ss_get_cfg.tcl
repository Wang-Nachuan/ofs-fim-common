## Copyright (C) 2023 Intel Corporation
## SPDX-License-Identifier: MIT

##
## Script for composing a description of the channel interfaces of a Memory Subsystem IP file with qsys-script.
## This is used to configure the OFS reference design to match an IP configuration.
## The reference design only supports homogenous channel instantiation and does not support Associative Storage
## application channels. Designs that require more elaborate channel configuration are instructed to implement
## their own subsystem design integration.
##
## Do not use the --script argument. Instead, invoke qsys-script with a
## project and system-file, adding:
##
##     --cmd="source <path to this script>; emit_ip_cfg <generated .vh file name> <subsystem name>"
## e.g.:
##     --cmd="source mem_ss_get_cfg.tcl; emit_ip_cfg mem_ss_cfg.vh MEM_SS"
##
## The subsystem name is included in each symbol written to the .vh file"
##

package require qsys

# List copy
proc lcopy {dest src} {
    upvar $dest mydest $src mysrc
    foreach key [ array names mysrc ] {
        set mydest($key) $mysrc($key)
    }
    return
}

# Compare list A and B
proc lcompare {a b} {
    upvar $a my_a $b my_b
    if { [array size my_a] != [array size my_b] } {
        return 0
    }

    foreach {key val} [array get my_a] {
        if { ![info exists my_b($key)] } {
            return 0
        }
        if { $my_b($key) != $val } {
            return 0
        }
    }

    return 1
}

proc emit_ip_cfg {ofile_name ip_name} {
    set asp_file_name [string map {".vh" "\_asp.qprs"} $ofile_name]
    puts ${asp_file_name}
    set of [open $ofile_name w]

    puts $of "//"
    puts $of "// Generated by OFS script mem_ss_get_cfg.tcl using qsys-script"
    puts $of "//"
    puts $of ""

    puts $of "`ifndef __OFS_FIM_IP_CFG_${ip_name}__"
    puts $of "`define __OFS_FIM_IP_CFG_${ip_name}__ 1"
    puts $of ""
   
   
    # Find the instance name in the IP's namespace (expecting one instance)
    set instances [get_instances]
    if { [llength $instances] != 1 } {
        send_message ERROR "Expected one instance in Memory Subsystem IP"
        exit 1
    }
    


    set inst [lindex $instances 0]
    set inst_entity [get_instance_property $inst CLASS_NAME]
    
    # Message for deprecated IP
    if { [string equal $inst_entity "mem_ss_fm"] } {
        send_message WARNING "${inst_entity} is provided by Quartus as a beta version and support in OFS is subject to change in the future"
    }

    # Read IP parameters
    foreach p [get_instance_parameters $inst] {
        #################################################################
        # Parameter parsing for deprecated IP
        if { [string equal $p "NUM_OF_PHYSICAL_INTERFACES"] } {
            set num_mem_phy [get_instance_parameter_value $inst $p]
        }

        if { [string equal "DIAG_ENABLE_CSR" $p ] } {
            if { [get_instance_parameter_value $inst $p] } {
                puts $of "// Connect Memory Subsystem to AXI-Lite CSR fabric "
                puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_CSR"
            }
        }
        # Process per channel params
        # HPS or EMIF?
        if { [regexp "^MEM_TYPE_ENUM_(.*)" $p match channel] } {
            set channel_type($channel) [get_instance_parameter_value $inst $p]
        }
        # Remove once mem_ss_fm IP is no longer available
        #################################################################

        # Parameter parsing for officially supported IP
        if { [string equal "MEM_INTFS_TYPE" $p] } {
            # A space-separated list of memory PHY channel types
            set mem_channels [split [get_instance_parameter_value $inst $p]]
        }

        if { [string equal "APP_INTFS_TYPE" $p] } {
            # A space-separated list of memory application channel types
            # OFS currently only supports STORAGE (AXI-MM) and HPS
            set app_channels [split [get_instance_parameter_value $inst $p]]
        }

        if { [string equal "ENABLE_MEM_CSR_INTF" $p ] } {
            # Enable routing to Subsystem CSR interface
            if { [string equal "ENABLED" [get_instance_parameter_value $inst $p]] } {
                puts $of "// Connect Memory Subsystem to AXI-Lite CSR fabric "
                puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_CSR"
            }
        }
        if { [regexp "^MEM_CH_(.*)_CONNS" $p match channel] } {
            # The application->physical channel connections. Use to determine which channel HPS is connected to.
            set channel_conns($channel) [get_instance_parameter_value $inst $p]
        }
    }

    #################################################################
    # Map old IP param structures to new IP
    # The old IP will only ever support DDR4 and 1-to-1 application-to-mem channel mapping
    if { [string equal $inst_entity "mem_ss_fm"] } {
        for {set channel 0} { $channel < $num_mem_phy } {incr channel} {
            lappend channel_conn_list 0
        }

        for {set channel 0} { $channel < $num_mem_phy } {incr channel} {
            if { [string equal $channel_type($channel) "MEM_TYPE_HPS_EMIF_DDR4"] } {
                lappend app_channels "HPS"
                set channel_conns($channel) [lreplace $channel_conn_list $channel $channel 1]
            } else {
                lappend app_channels "STORAGE"
            }
            lappend mem_channels "DDR4"
        }
    }
    # Remove once mem_ss_fm IP is no longer available
    #################################################################

    puts $of ""
    puts $of "//"
    puts $of "// Flags to enable memory channel instantiation/configuration "
    puts $of "//"

    puts $of "`define OFS_FIM_IP_CFG_${ip_name}_ENTITY ${inst_entity}"

    # Interpret mem_ss channel interface parameters
    set num_axi_channels 0
    for {set channel 0} { $channel < [llength $app_channels] } {incr channel} {
        set type [lindex $app_channels $channel]
        if { [string equal "ASSOCIATIVE_STORAGE" $type] } {
            send_message ERROR "Memory Subsystem lookup interface is unsupported in the OFS reference FIM!"
            exit 1
        }

        if { [string equal "STORAGE" $type] } {
            set interface "i${channel}_axi_mm"
            foreach port [get_interface_ports $interface] {
                # Clean the AXI-MM port name of subsystem prefix (i#_ ss_ app_) mm_
                set axi_port [string trimleft [string trimleft $port "i${channel}sap_"] "m_"]
                set axi_ch_width($axi_port) [get_interface_port_property $interface $port WIDTH]
            }
            if { [info exists axi_width] } {
                if { ![lcompare axi_width axi_ch_width] } {
                    send_message ERROR "Mismatched Memory Subsystem channel settings are unsupported in the OFS reference FIM!"
                    exit 1
                }
            } else {
                lcopy axi_width axi_ch_width
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_AXI_MM_${channel}"
            incr num_axi_channels
        }
        if { [string equal "HPS" $type] } {
            # Search channel connection map for the channel attached to HPS
            # Agilex HPS only supports 1 HPS channel so no need to search all
            set hps_channel [lsearch [split $channel_conns(${channel})] "1"]
        }
    }

    # mem_ss interface ports
    set num_ddr4_channels 0
    for {set channel 0} { $channel < [llength $mem_channels] } {incr channel} {
        set type [lindex $mem_channels $channel]
        if { ![string equal "DDR4" $type] } {
            send_message ERROR "Unsupported memory type ${type} assigned to Memory Channel ${channel}!"
            exit 1
        }

        if { [info exists hps_channel] && ($hps_channel == $channel) } {
            set interface "mem${channel}_ddr4"
            foreach port [get_interface_ports $interface] {
                # Clean the DDR4 port name of subsystem prefix (mem#_ ddr4_)
                set mem_port [string trimleft [string trimleft [string trimleft $port "mem${channel}_"] "ddr4"] "_"]
                set hps_width($mem_port) [get_interface_port_property $interface $port WIDTH]
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_HPS_EMIF_IS_MEM_${channel}"
        } else {

            set interface "mem${channel}_ddr4"
            foreach port [get_interface_ports $interface] {
                # Clean the DDR4 port name of subsystem prefix (mem#_ ddr4_)
                set mem_port [string trimleft [string trimleft [string trimleft $port "mem${channel}_"] "ddr4"] "_"]
                set ddr4_ch_width($mem_port) [get_interface_port_property $interface $port WIDTH]
            }
            if { [info exists ddr4_width] } {
                if { ![lcompare ddr4_width ddr4_ch_width] } {
                    send_message ERROR "Mismatched memory subsystem channel settings are unsupported in the OFS reference FIM!"
                    exit 1
                }
            } else {
                lcopy ddr4_width ddr4_ch_width
            }

            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_EN_MEM_${channel}"
            incr num_ddr4_channels
        }
    }

    # Define the AXI-MM interface widths
    # Filter AXI ports for the ones that are user configurable
    set axi_ports {rdata wdata awlen awuser awid awaddr buser}
    if { [info exists axi_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// AXI-MM user interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_USER_AXI"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_NUM_AXI_CHANNELS ${num_axi_channels}"
        foreach port $axi_ports {
            if { [string first "data" $port] != -1 } {
                # Memory supports assymetric read/write data widths
                set PORT [string toupper $port]
            } elseif { [string first "buser" $port] != -1 } {
                set PORT [string toupper $port]
            } else {
                # Otherwise clean the channel specific prefix from the AXI port
                set PORT [string toupper [string trimleft [string trimleft $port "a"] "w"]]
            }
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_AXI_${PORT}_WIDTH $axi_width($port)"
        }
    }

    # Define the PHY interfaces
    # Define the Fabric EMIF DDR4 interface widths
    if { [info exists ddr4_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// Fabric EMIF interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_EMIF_DDR4"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_NUM_DDR4_CHANNELS ${num_ddr4_channels}"
        foreach {port width} [array get ddr4_width] {
            set PORT [string toupper $port]
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DDR4_${PORT}_WIDTH $width"
            if { [string match "*dq" $port]} {
             set dq_width_in_bytes [expr $width/8]
            }
        }
    }

    # define the HPS EMIF DDR4 interface widths
    if { [info exists hps_width] } {
        puts $of ""
        puts $of "//"
        puts $of "// HPS EMIF interface configuration "
        puts $of "//"
        puts $of "`define OFS_FIM_IP_CFG_${ip_name}_DEFINES_HPS_DDR4"
        foreach {port width} [array get hps_width] {
            set PORT [string toupper $port]
            puts $of "`define OFS_FIM_IP_CFG_${ip_name}_HPS_${PORT}_WIDTH $width"
        }
    }

    puts $of ""
    puts $of "`endif // `ifndef __OFS_FIM_IP_CFG_${ip_name}__"

    close $of

    #The ASP takes in parameters from the FIM to configure the design appropriately.
    #The code below generarates a qprs file with some parameters that describe the 
    #FIM configuration
    # Generating values that the FIM is configured with for ASP configuration
    set of [open $asp_file_name w]   
     puts $of "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
     puts $of "<!--\\"
     puts $of "  Generated by OFS script mem_ss_get_cfg.tcl using qsys-script"
     puts $of "-->"
     puts $of "<ip>"
     puts $of " <presets version=\"12.1\">"
     puts $of "  </preset"
     puts $of "     name=\"oneapi_asp_preset\""
     puts $of "     kind=\"oneAPI_kernel_wrapper\""
     puts $of "     version=\"All\""
     puts $of "     description=\"\""
     puts $of "     board=\"\""
     puts $of "     preset_category=\"\">"
     set axi_ports {rdata wdata awaddr}
     if { [info exists axi_width] } {
        puts $of "   <parameter name=\"OFS_FIM_IP_CFG_${ip_name}_NUM_AXI_CHANNELS\" value=\"${num_axi_channels}\"/>"
        foreach port $axi_ports {
            if { [string first "data" $port] != -1 } {
                # Memory supports assymetric read/write data widths
                set PORT [string toupper $port]
            } elseif { [string first "buser" $port] != -1 } {
                set PORT [string toupper $port]
            } else {
                # Otherwise clean the channel specific prefix from the AXI port
                set PORT [string toupper [string trimleft [string trimleft $port "a"] "w"]]
            }
            puts $of "   <parameter name=\"OFS_FIM_IP_CFG_${ip_name}_AXI_${PORT}_WIDTH\" value=\"$axi_width($port)\"/>"
            if { [string first "data" $port] != -1 } {
                puts $of "   <parameter name=\"OFS_FIM_IP_CFG_${ip_name}_AXI_${PORT}_BURST_COUNT\" value=\"256\"/>"
            }
        }
     } else {
            puts $of "   <parameter name=\"OFS_FIM_IP_CFG_${ip_name}_DEFINES_USER_AXI\" value=\"FALSE\"/>"        
     }

    # The ASP needs to know the theoretical max bw of the DDR banks.
    set ip_file [get_module_property FILE]
    set ip_file_name [string tolower ${ip_name}]
    set ip_file_name ${ip_file_name}.ip
    puts "${ip_file_name}"
    # this is working around an issue where the load_system is not working unless
    # the ip is avialable in the working directory
    if { [file exists $ip_file_name] == 0} { 
        exec ln -s ${ip_file} .
    }
    create_system t1
    add_component mem_ss_inst $ip_file
    load_component mem_ss_inst
    load_system_inside_package
    load_component emif_0
    
    set mem_clk_freq  [get_component_parameter_value PHY_DDR4_MEM_CLK_FREQ_MHZ]
    set theoretical_max_bw_GBps [expr {($mem_clk_freq*2*$num_ddr4_channels*$dq_width_in_bytes)/1000}]
    puts $of "   <parameter name=\"OFS_FIM_IP_CFG_${ip_name}_THEORETICAL_MAX_BW_GBps\" value=\"${theoretical_max_bw_GBps}\"/>"        

    puts $of "  </preset>"
    puts $of " </preset>"
    puts $of "</ip>"
    close $of

}
